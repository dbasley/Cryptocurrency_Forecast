---
title: "Bitcoin EDA"
author: "Devin Basley"
date: "2024-04-01"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Hypotheses

1. Bitcoin Close Price will continue to increase by end of 2024, and March 2026

2. Smaller/Other Cryptocurrencies follow the performance of Bitcoin

3. Bitcoin Log Returns follow volatility clustering
 
 
# Bitcoin EDA


## Load Data
```{r}

library(tidyverse)
bitcoin <- read.csv("~/Downloads/Time Series/Cryptocurrency_Forecast/bitcoin_history.csv")

smaller_crypto <- read.csv("~/Downloads/Time Series/Cryptocurrency_Forecast/smaller_crypto.csv")

bnb <- smaller_crypto %>%
  filter(name == "BNB")

ethereum <- smaller_crypto %>%
  filter(name == "Ethereum")


```


# Convert Bitcoin, BNB, Ethereum log close price to TS

```{r}

bitcoin_close <- ts(log(bitcoin$close), start = c(2017,1), end = c(2023,12), frequency = 365)
bnb_close <- ts(log(bnb$close), start = c(2017, 1), end = c(2023,12), frequency = 365)
ethereum_close <- ts(log(ethereum$close), start = c(2017, 1), end = c(2023,12), frequency = 365)

time1 <- time(ts(start = c(2017, 1), end = c(2023, 12), frequency = 365))
#time2 <- time(ts(start = c(2017, 1), end = c(2023, 12), frequency = 365))


plot(bitcoin_close, col = "black", 
     xlab = "Date", 
     ylab = "Bitcoin Close Price", 
     main = "Bitcoin Close Price From 2017-2023")

par(mfrow=c(1,2))
acf(bitcoin$close, lag.max = 2000, main= "ACF plot of bitcoin")
pacf(bitcoin_close, lag = 2000, main="PACF plot of bitcoin")


plot(log(bitcoin_close), col = "black", ylim = c(0,15), 
     xlab = "Date", 
     ylab = "Logged Coin Close Price", 
     main = "Cryptocurrency Logged Close Price Over Time")
lines(log(bnb_close), col = "skyblue")
lines(log(ethereum_close), col = "red")
legend("topleft", 
       legend = c("Bitcoin", "BNB", "Ethereum"), 
       col = c("black", "skyblue", "red"), lty = 1)


```


# Detrended Linear Regression Model

```{r}
bitcoin_lm_fit <- lm(diff(bitcoin_close) ~ diff(time1), data = bitcoin)
bitcoin_detrend <- diff(bitcoin_close) - fitted(bitcoin_lm_fit)



bnb_lm_fit <- lm(diff(bnb_close) ~ diff(time1), data = bnb)
bnb_detrend <- diff(bnb_close) - fitted(bnb_lm_fit)

ether_lm_fit <- lm(diff(ethereum_close) ~ diff(time1), data = ethereum)
ether_detrend <- diff(ethereum_close) - fitted(ether_lm_fit)

par(mfrow = c(3,1))
plot(bitcoin_detrend)
plot(bnb_detrend)
plot(ether_detrend)

```





# Vector AR Model

```{r}
library(vars)

detrend_crypto <- data.frame(bitcoin_detrend, bnb_detrend, ether_detrend)

var_analysis <- VARselect(detrend_crypto, type = "none")

var_analysis$selection

crypto_var <- VAR(detrend_crypto, type = "none", p = 1)

summary(crypto_var)

```






# Bitcoin Log Returns

```{r}

bitcoin_log_return <- diff(bitcoin_close)

bitcoin_log_return <- ts(bitcoin_log_return, start = c(2017,1), end = c(2023,12), frequency = 365)


```

# Plot Bitcoin Close Price and Log Returns

```{r}

plot(bitcoin_close, main = 
       'Close Price Bitcoin')

plot(bitcoin_log_return, main = "Bitcoin Detrended",
     ylab = "Difference and Logged Bitcoin Close Price")

```

# Close Price ACF and PACF

```{r}


acf(bitcoin_close)
pacf(bitcoin_close)




```


# Bitcoin Log Returns ACF and PACF plots

```{r}
par(mfrow=c(2,2))
acf(bitcoin_log_return, main = "ACF of Bitcoin Log Return")
pacf(bitcoin_log_return, main = "PACF of Bitcoin Log Return")
acf(bitcoin_log_return^2, main = "ACF of Bitcoin Log Return Squared")
pacf(bitcoin_log_return^2, main = "PACF of Bitcoin Log Return Squared")




```

# ARMA Model

```{r}

library(forecast)



returns_arma <- auto.arima(bitcoin_log_return^2, max.p = 5, max.q = 5, 
                  max.order = 10, stationary = T, 
                  seasonal = F, trace = T, stepwise = F, 
                  approximation = F)

```

# Bitcoin Squared Log Returns Residuals Checks

```{r}

# Fit ARMA(3,0,3) model
arma_model <- arima(bitcoin_log_return^2, order=c(3,0,3))
residuals_arma <- residuals(arma_model)

acf(residuals_arma)
pacf(residuals_arma)

# Squared residuals
squared_residuals <- residuals_arma^2

# ACF and PACF plots
acf_sqr_residuals <- acf(squared_residuals, main = "ACF of Log Returns Squared Residuals")
pacf_sqr_residuals <- pacf(squared_residuals, main = "PACF of Log Returns Squared Residuals")


```


# Bitcoin Returns GARCH Model

```{r}

library(fGarch)
library(xts)

# Define GARCH model 
garch_fit <- garchFit(~garch(1, 3), 
                        data = bitcoin_log_return)
garch_fit2 <- garchFit(~garch(2, 3), 
                        data = bitcoin_log_return)
garch_fit3 <- garchFit(~garch(3, 3), 
                        data = bitcoin_log_return)


gfit_parameters <- (garch_fit@fit)$matcoe

gfit_parameters


# Summarize the model
summary(garch_fit)
summary(garch_fit2)
summary(garch_fit3)

# Plot Garch Model
#plot(garch_fit, which = 1)
plot(garch_fit3, which = 2)
plot(garch_fit3, which = 7)


```


# Visualize GARCH fit Bitcoin Log Returns

```{r}

std_t <- garch_fit3@sigma.t

std_t

plot(ts(bitcoin_log_return), main = "Conditional SD on Actual Bitcoin Data",
     ylab = "Bitcoin Log Return")
lines(garch_fit3@sigma.t, col = "skyblue", pch = 30)

```


# Forecast Bitcoin

```{r}

library(rugarch)

model.7 <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(3, 3)), 
                      mean.model = list(armaOrder = c(3, 3), include.mean = FALSE), 
                      distribution.model = "norm")
m.56_32 <- ugarchfit(spec = model.7, data = ts(bitcoin_log_return), out.sample = 200)
m.56_32


forc.56_22 = ugarchforecast(m.56_32, data = ts(bitcoin_log_return), n.ahead = 90, n.roll = 90)
plot(forc.56_22, which = "all")

forc.56_22

```